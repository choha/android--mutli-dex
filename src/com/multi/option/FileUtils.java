package com.multi.option;import java.io.BufferedInputStream;import java.io.BufferedOutputStream;import java.io.File;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import android.content.Context;public class FileUtils {    /**     * 将assents目录中的dex文件复制data/data/package/files目录中     *      * @param con     * @param dex_file 需要赋值的文件对象     * @return     */    public static String copy(Context con, String dex_file) {        String filepatch = con.getFilesDir().getPath() + File.separator + dex_file;        File dexFile = new File(filepatch);        // 如果文件存在，就不在复制，这里应该根据版本号升级情况判断是否需要重新覆盖        if (dexFile.exists()) {            return filepatch;        }        try {            FileOutputStream fos = new FileOutputStream(filepatch);            InputStream is = con.getAssets().open(dex_file);            copyFile(is, fos);        } catch (FileNotFoundException e) {            // TODO Auto-generated catch block            e.printStackTrace();        } catch (IOException e) {            // TODO Auto-generated catch block            e.printStackTrace();        }        return filepatch;    }    /**     * 复制文件     *      * @param is 源文件的输入流     * @param os 目标文件的输出流     */    public static final boolean copyFile(InputStream is, FileOutputStream os) {        BufferedInputStream bis = null;        BufferedOutputStream bos = null;        byte[] buffer = new byte[4096];        int length;        try {            bis = new BufferedInputStream(is);            bos = new BufferedOutputStream(os);            while ((length = bis.read(buffer)) != -1) {                bos.write(buffer, 0, length);            }            bos.flush();            return true;        } catch (IOException e) {            e.printStackTrace();            return false;        } finally {            try {                if (bis != null) {                    bis.close();                }                if (bos != null) {                    bos.close();                }            } catch (IOException e) {                e.printStackTrace();                return false;            }        }    }}